/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package solution

import solution.annotation.LeetcodeMetaConfig
import solution.annotation.LeetcodeMetaInfo
import java.io.File
import java.util.PriorityQueue

fun extractQuestionNameFromUrl(url: String): String {
    val paths = url.split("/").filter { it.isNotEmpty() }
    val tokens = paths.last().split("-")
    return tokens.joinToString(" ")
}
fun main() {
    val questions = LeetcodeMetaConfig.getQuestionList().groupBy { it.level }
    val sortedQuestions = mutableListOf<LeetcodeMetaInfo>()
    for (k in arrayOf("EASY", "MEDIUM", "HARD")) {
        sortedQuestions.addAll(questions.getOrDefault(k, listOf()))
    }

    val builder = StringBuilder()
    builder.append("| Leetcode Link | Difficulty | [ELO Rating](https://zerotrac.github.io/leetcode_problem_rating) | Solution | Hint |\n")
    builder.append("| ------------- | ---------- | ---------- | -------- | ---- |\n")

    for (q in sortedQuestions) {
        val name = extractQuestionNameFromUrl(q.link)
        builder.append("| ")
        builder.append("${q.id}. [$name](${q.link}) | ")
        builder.append("${q.level} | ")
        builder.append("${q.rating} | ")
        builder.append("[link](https://github.com/likexx/leetcode-kotlin/blob/main/app/src/main/kotlin/solution/Solution${q.id}.kt) | ")
        builder.append("${q.hint?:""} | ")
        builder.append("|\n")
    }

    File("../docs/README.md").writeText(builder.toString())
}

class Solution {
    fun getSkyline(buildings: Array<IntArray>): List<List<Int>> {
        val points= mutableListOf<Pair<Int, Int>>()

        for (b in buildings) {
            points.add(Pair(b[0], -b[2]))
            points.add(Pair(b[1], b[2]))
        }
        points.sortWith(Comparator{ p1, p2 ->
            if (p1.first!=p2.first) {
                return@Comparator p1.first.compareTo(p2.first)
            }
            return@Comparator p1.second.compareTo(p2.second)
        })

        val result= arrayListOf<List<Int>>()
        val maxHeap=PriorityQueue<Int>()
        var curHeight=0
        maxHeap.add(0)

        for (p in points) {
            val x=p.first
            val h=p.second
            if (h<0) {
                maxHeap.add(h)
            } else {
                // remove the left point
                maxHeap.remove(-h)
            }
            if (curHeight != -maxHeap.peek()) {
                curHeight = -maxHeap.peek()
                result.add(listOf(x, curHeight))
            }
        }

        return result.toList()
    }
}
